{"moduleInfo":{"moduleName":"Flamecomics","moduleInitials":"FC","moduleDesc":"Flamecomics, previously FlameScans Module","developer":"Scrumptious","moduleID":"20231123","moduleImage":"https://i.postimg.cc/Dy2qf4W4/icon.png","moduleVersion":2,"moduleLenguage":"English","moduleType":"Image","baseURL":"https://flamecomics.xyz/","moduleDeveloperSite":"https://github.com/OffsetParts/KetsuModules/","UpdateSite":"https://raw.githubusercontent.com/OffsetParts/KetsuModules/master/Modules/FlameScans/Flamecomics.json","preferedServer":"","preferedDownloadServer":"","blackListed":[""],"fileType":"moduleInfo","fileSection":"Module","fileID":3955225847,"fileName":"moduleInfo.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"params":{"name":"Settings Editor","route":[],"status":true}},"fileIndexPath":[2,0]},"global":{"variables":[{"key":"","value":""}],"cookies":[{"key":"","value":""}],"headers":[{"key":"","value":""}]},"mainPage":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            store.set(\"ketsu_dynamic_raw\", currentURL); // THIS\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: request(store.get(\"ketsu_dynamic_raw\") || metadata().request.url),\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [], function (exports_2, context_2) {\n    \"use strict\";\n    var __moduleName = context_2 && context_2.id;\n    function cleanUrl(url) {\n        return 'https://flamecomics.xyz' + url.trim();\n    }\n    exports_2(\"cleanUrl\", cleanUrl);\n    function cleanText(str) {\n        return str.replace(/[\\n\\t]/g, '').trim();\n    }\n    exports_2(\"cleanText\", cleanText);\n    function cleanImage(imageUrl) {\n        // If image already has domain, return as-is\n        if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {\n            return imageUrl;\n        }\n        // Otherwise, prepend FlameComics domain\n        return 'https://flamecomics.xyz' + imageUrl;\n    }\n    exports_2(\"cleanImage\", cleanImage);\n    return {\n        setters: [],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"mainPage\", [\"core\", \"shared\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core, shared_1, res, carouselElm, Carousel, popularElm, Popular, staffPickedElm, StaffPicked, latestElm, Latests;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            },\n            function (shared_1_1) {\n                shared_1 = shared_1_1;\n            }\n        ],\n        execute: async function () {\n            // Fetch main page\n            res = await core.fetch('https://flamecomics.xyz/', { loadInSite: true, removeScripts: false });\n            // Carousel - Top featured manga (GOAT section)\n            carouselElm = res.querySelectorAll('div[class*=mantine-Carousel-slide]');\n            Carousel = Array.from(carouselElm).map(entry => {\n                const link = shared_1.cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n                const banner = entry.querySelector('img')?.getAttribute('src') || '';\n                const title = shared_1.cleanText(entry.querySelector('h3')?.textContent || '');\n                return core.view({\n                    link: core.request(link),\n                    image: core.request(shared_1.cleanImage(banner)),\n                    title: title\n                });\n            });\n            // Popular Today\n            popularElm = res.querySelectorAll('div[id=\"popular\"] > div > div');\n            Popular = Array.from(popularElm).map(entry => {\n                const title = shared_1.cleanText(entry.querySelector('p')?.textContent || '');\n                const link = shared_1.cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n                const image = entry.querySelector('img')?.getAttribute('src') || '';\n                return core.view({\n                    link: core.request(link),\n                    image: core.request(shared_1.cleanImage(image)),\n                    title: title\n                });\n            });\n            // Staff Picked\n            staffPickedElm = res.querySelectorAll('div[id=\"staff-picks\"] > div > div');\n            StaffPicked = Array.from(staffPickedElm).map(entry => {\n                const title = shared_1.cleanText(entry.querySelector('p')?.textContent || '');\n                const link = shared_1.cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n                const image = entry.querySelector('img')?.getAttribute('src') || '';\n                return core.view({\n                    link: core.request(link),\n                    image: core.request(shared_1.cleanImage(image)),\n                    title: title\n                });\n            });\n            // Latest Chapters\n            latestElm = res.querySelectorAll('div[id=\"latest\"] > div > div');\n            Latests = Array.from(latestElm).map(entry => {\n                const title = shared_1.cleanText(entry.querySelector('a[class*=mantine-Text-root]')?.textContent || '');\n                const link = shared_1.cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n                const image = entry.querySelector('img')?.getAttribute('src') || '';\n                const chapter = shared_1.cleanText(entry.querySelector('p')?.textContent || '');\n                return core.view({\n                    link: core.request(link),\n                    image: core.request(shared_1.cleanImage(image)),\n                    title: title,\n                    description: chapter\n                });\n            });\n            // Build the main page layout\n            core.main([\n                core.viewsHolder({\n                    orientation: \"horizontal\",\n                    distribution: 'longDoubletsFull',\n                    design: \"normal1\",\n                    title: \"\",\n                    views: Carousel\n                }),\n                core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"normal4\",\n                    distribution: \"longTriplets\",\n                    title: \"Popular Today\",\n                    views: Popular\n                }),\n                core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"normal4\",\n                    distribution: \"longTriplets\",\n                    title: \"Staff Picked\",\n                    views: StaffPicked\n                }),\n                core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"wide9\",\n                    distribution: \"wideStrechedList\",\n                    title: \"Latest Chapters\",\n                    views: Latests\n                })\n            ]);\n        }\n    };\n});\n\n            System.import(\"mainPage\");\n            "},"output":[{"cellDesing":"normal1","orientation":"vertical","defaultLayout":"wide","paging":"","section":{"sectionName":"","separator":false},"layout":{"insets":{"top":0,"bottom":0,"left":0,"right":0},"visibleCellsWidthS":2,"visibleCellsWidthM":2,"visibleCellsWidthL":2,"visibleCellsHeight":2,"heightForVisibleCells":400,"cellSize":{"width":300,"height":300},"ratio":{"inRelation":"width","number1":1,"number2":2},"constant":{"width":1,"height":2},"horizontalSpacing":0,"verticalSpacing":0},"data":[{"image":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"title":"","description":"","field1":"","field2":"","field3":"","field4":"","openInWebView":false,"isChapter":false,"link":{"url":"","method":"","headers":[{"key":"","value":""}],"httpBody":null}}]}],"fileType":"mainPage","fileSection":"Module","fileID":2253367988,"fileName":"mainPage.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport { cleanUrl, cleanText, cleanImage } from './shared';\n\n// Fetch main page\nlet res = await core.fetch('https://flamecomics.xyz/', {loadInSite: true, removeScripts: false});\n\n// Carousel - Top featured manga (GOAT section)\nconst carouselElm = res.querySelectorAll('div[class*=mantine-Carousel-slide]');\nlet Carousel = Array.from(carouselElm).map(entry => {\n    const link = cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n    const banner = entry.querySelector('img')?.getAttribute('src') || '';\n    const title = cleanText(entry.querySelector('h3')?.textContent || '');\n\n    return core.view({\n        link: core.request(link),\n        image: core.request(cleanImage(banner)),\n        title: title\n    });\n});\n\n// Popular Today\nconst popularElm = res.querySelectorAll('div[id=\"popular\"] > div > div');\nlet Popular = Array.from(popularElm).map(entry => {\n    const title = cleanText(entry.querySelector('p')?.textContent || '');\n    const link = cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n    const image = entry.querySelector('img')?.getAttribute('src') || '';\n\n    return core.view({\n        link: core.request(link),\n        image: core.request(cleanImage(image)),\n        title: title\n    });\n});\n\n// Staff Picked\nconst staffPickedElm = res.querySelectorAll('div[id=\"staff-picks\"] > div > div');\nlet StaffPicked = Array.from(staffPickedElm).map(entry => {\n    const title = cleanText(entry.querySelector('p')?.textContent || '');\n    const link = cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n    const image = entry.querySelector('img')?.getAttribute('src') || '';\n\n    return core.view({\n        link: core.request(link),\n        image: core.request(cleanImage(image)),\n        title: title\n    });\n});\n\n// Latest Chapters\nconst latestElm = res.querySelectorAll('div[id=\"latest\"] > div > div');\nlet Latests = Array.from(latestElm).map(entry => {\n    const title = cleanText(entry.querySelector('a[class*=mantine-Text-root]')?.textContent || '');\n    const link = cleanUrl(entry.querySelector('a')?.getAttribute('href') || '');\n    const image = entry.querySelector('img')?.getAttribute('src') || '';\n    const chapter = cleanText(entry.querySelector('p')?.textContent || '');\n\n    return core.view({\n        link: core.request(link),\n        image: core.request(cleanImage(image)),\n        title: title,\n        description: chapter\n    });\n});\n\n// Build the main page layout\ncore.main([\n    core.viewsHolder({\n        orientation: \"horizontal\",\n        distribution: 'longDoubletsFull',\n        design: \"normal1\",\n        title: \"\",\n        views: Carousel\n    }),\n    core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"normal4\",\n        distribution: \"longTriplets\",\n        title: \"Popular Today\",\n        views: Popular\n    }),\n    core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"normal4\",\n        distribution: \"longTriplets\",\n        title: \"Staff Picked\",\n        views: StaffPicked\n    }),\n    core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"wide9\",\n        distribution: \"wideStrechedList\",\n        title: \"Latest Chapters\",\n        views: Latests\n    })\n]);","type":"typescript","compiled":true,"status":true,"shared":false,"line":51}},"fileIndexPath":[3,0]}],"search":[{"request":{"url":"https://google.com/?ketsu_search=<searched>&ketsu_page=<page>","method":"GET","headers":[{"key":"","value":""}]},"separator":"","extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            store.set(\"ketsu_dynamic_raw\", currentURL); // THIS\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: request(store.get(\"ketsu_dynamic_raw\") || metadata().request.url),\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [], function (exports_2, context_2) {\n    \"use strict\";\n    var __moduleName = context_2 && context_2.id;\n    function cleanUrl(url) {\n        return 'https://flamecomics.xyz' + url.trim();\n    }\n    exports_2(\"cleanUrl\", cleanUrl);\n    function cleanText(str) {\n        return str.replace(/[\\n\\t]/g, '').trim();\n    }\n    exports_2(\"cleanText\", cleanText);\n    function cleanImage(imageUrl) {\n        // If image already has domain, return as-is\n        if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {\n            return imageUrl;\n        }\n        // Otherwise, prepend FlameComics domain\n        return 'https://flamecomics.xyz' + imageUrl;\n    }\n    exports_2(\"cleanImage\", cleanImage);\n    return {\n        setters: [],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"search\", [\"core\", \"shared\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core, shared_1, SM, res, seriesCards, results;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            },\n            function (shared_1_1) {\n                shared_1 = shared_1_1;\n            }\n        ],\n        execute: async function () {\n            // Get search metadata (search query)\n            SM = core.searchMetadata();\n            // Fetch the series list page (all comics)\n            res = await core.fetch('https://flamecomics.xyz/browse', { loadInSite: true, removeScripts: false });\n            // Extract all series cards\n            seriesCards = res.querySelectorAll('.DescSeriesCard_cardContainer__39kZS');\n            // Filter and map results based on search query\n            results = Array.from(seriesCards)\n                .map((card) => {\n                // Extract title\n                const titleElem = card.querySelector('.DescSeriesCard_title__iuEre');\n                const title = shared_1.cleanText(titleElem?.textContent || '');\n                // Extract link\n                const linkElem = card.querySelector('a[href^=\"/series/\"]');\n                const link = linkElem?.getAttribute('href') || '';\n                // Extract image\n                const imgElem = card.querySelector('img');\n                const image = imgElem?.getAttribute('src') || '';\n                // Extract status badge\n                const statusBadge = card.querySelector('.mantine-Badge-root[data-variant=\"outline\"]');\n                const status = statusBadge ? shared_1.cleanText(statusBadge.textContent || '') : '';\n                // Extract genres\n                const genreBadges = card.querySelectorAll('.DescSeriesCard_categories__0736e .mantine-Badge-root');\n                const genres = Array.from(genreBadges).map((badge) => shared_1.cleanText(badge.textContent || '')).join(', ');\n                return {\n                    title,\n                    link,\n                    image,\n                    status,\n                    genres\n                };\n            })\n                .filter(item => {\n                // Filter by search query (case-insensitive)\n                const searchLower = SM.searched.toLowerCase();\n                return item.title.toLowerCase().includes(searchLower);\n            })\n                .map(item => {\n                return core.view({\n                    link: core.request(shared_1.cleanUrl(item.link)),\n                    image: core.request(shared_1.cleanImage(item.image)),\n                    title: item.title,\n                    description: item.status,\n                    field1: item.genres\n                });\n            });\n            // Return search results\n            core.search([\n                core.viewsHolder({\n                    title: `Search Results for \"${SM.searched}\"`,\n                    design: 'wide9',\n                    distribution: 'wideStrechedList',\n                    orientation: 'vertical',\n                    views: results\n                })\n            ]);\n        }\n    };\n});\n\n            System.import(\"search\");\n            "},"output":[{"cellDesing":"normal1","orientation":"vertical","defaultLayout":"wide","paging":"","section":{"sectionName":"","separator":false},"layout":{"insets":{"top":0,"bottom":0,"left":0,"right":0},"visibleCellsWidthS":2,"visibleCellsWidthM":2,"visibleCellsWidthL":2,"visibleCellsHeight":2,"heightForVisibleCells":400,"cellSize":{"width":300,"height":300},"ratio":{"inRelation":"width","number1":1,"number2":2},"constant":{"width":1,"height":2},"horizontalSpacing":0,"verticalSpacing":0},"data":[{"image":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"title":"","description":"","field1":"","field2":"","field3":"","field4":"","openInWebView":false,"isChapter":false,"link":{"url":"empty","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}],"fileType":"search","fileSection":"Module","fileID":1463255157,"fileName":"search.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport { cleanUrl, cleanText, cleanImage } from './shared';\n\n// Get search metadata (search query)\nlet SM = core.searchMetadata();\n\n// Fetch the series list page (all comics)\nlet res = await core.fetch('https://flamecomics.xyz/browse', {loadInSite: true, removeScripts: false});\n\n// Extract all series cards\nconst seriesCards = res.querySelectorAll('.DescSeriesCard_cardContainer__39kZS');\n\n// Filter and map results based on search query\nconst results = Array.from(seriesCards)\n    .map((card: any) => {\n        // Extract title\n        const titleElem = card.querySelector('.DescSeriesCard_title__iuEre');\n        const title = cleanText(titleElem?.textContent || '');\n        \n        // Extract link\n        const linkElem = card.querySelector('a[href^=\"/series/\"]');\n        const link = linkElem?.getAttribute('href') || '';\n        \n        // Extract image\n        const imgElem = card.querySelector('img');\n        const image = imgElem?.getAttribute('src') || '';\n        \n        // Extract status badge\n        const statusBadge = card.querySelector('.mantine-Badge-root[data-variant=\"outline\"]');\n        const status = statusBadge ? cleanText(statusBadge.textContent || '') : '';\n        \n        // Extract genres\n        const genreBadges = card.querySelectorAll('.DescSeriesCard_categories__0736e .mantine-Badge-root');\n        const genres = Array.from(genreBadges).map((badge: any) => \n            cleanText(badge.textContent || '')\n        ).join(', ');\n        \n        return {\n            title,\n            link,\n            image,\n            status,\n            genres\n        };\n    })\n    .filter(item => {\n        // Filter by search query (case-insensitive)\n        const searchLower = SM.searched.toLowerCase();\n        return item.title.toLowerCase().includes(searchLower)\n    })\n    .map(item => {\n        return core.view({\n            link: core.request(cleanUrl(item.link)),\n            image: core.request(cleanImage(item.image)),\n            title: item.title,\n            description: item.status,\n            field1: item.genres\n        });\n    });\n\n// Return search results\ncore.search([\n    core.viewsHolder({\n        title: `Search Results for \"${SM.searched}\"`,\n        design: 'wide9',\n        distribution: 'wideStrechedList',\n        orientation: 'vertical',\n        views: results\n    })\n]);","type":"typescript","compiled":true,"status":true,"shared":false,"line":51}},"fileIndexPath":[4,0]}],"info":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            store.set(\"ketsu_dynamic_raw\", currentURL); // THIS\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: request(store.get(\"ketsu_dynamic_raw\") || metadata().request.url),\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [], function (exports_2, context_2) {\n    \"use strict\";\n    var __moduleName = context_2 && context_2.id;\n    function cleanUrl(url) {\n        return 'https://flamecomics.xyz' + url.trim();\n    }\n    exports_2(\"cleanUrl\", cleanUrl);\n    function cleanText(str) {\n        return str.replace(/[\\n\\t]/g, '').trim();\n    }\n    exports_2(\"cleanText\", cleanText);\n    function cleanImage(imageUrl) {\n        // If image already has domain, return as-is\n        if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {\n            return imageUrl;\n        }\n        // Otherwise, prepend FlameComics domain\n        return 'https://flamecomics.xyz' + imageUrl;\n    }\n    exports_2(\"cleanImage\", cleanImage);\n    return {\n        setters: [],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"info\", [\"core\", \"shared\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core, shared_1, res, title, image, nextDataScript, seriesInfo, synopsis, state, type, genres, chapters;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            },\n            function (shared_1_1) {\n                shared_1 = shared_1_1;\n            }\n        ],\n        execute: async function () {\n            res = await core.dynamicFetch({ loadInSite: true, removeScripts: false });\n            // Extract basic info\n            title = shared_1.cleanText(res.querySelector('h1')?.textContent || '');\n            image = core.request(shared_1.cleanImage(res.querySelector('img')?.getAttribute('src') || ''));\n            nextDataScript = JSON.parse(res.querySelector('script[id=__NEXT_DATA__]')?.textContent || '{}').props?.pageProps || {};\n            seriesInfo = nextDataScript?.series;\n            synopsis = seriesInfo.description || '';\n            state = seriesInfo?.status || '';\n            type = seriesInfo?.type || '';\n            // Extract genres\n            genres = seriesInfo?.tags;\n            // Extract chapters from Next.js data\n            chapters = [];\n            if (nextDataScript) {\n                try {\n                    const chaptersData = nextDataScript.chapters || [];\n                    chapters = chaptersData.map((entry) => {\n                        const chapterNum = entry.chapter?.replace('.00', '') || '';\n                        const link = shared_1.cleanUrl(`/series/${entry.series_id}/${entry.token}`);\n                        const name = `Chapter ${chapterNum}`;\n                        return core.chapterRequest(link, {\n                            name: name,\n                            openInWebView: false\n                        });\n                    }).reverse();\n                }\n                catch (error) {\n                    console.error('Error parsing chapter data:', error);\n                }\n            }\n            // Build info page\n            core.info({\n                title: title,\n                image: image,\n                description: synopsis,\n                genres: genres,\n                field1: type,\n                field2: state,\n                field4: `Chapters: ${chapters.length}`,\n                chapters: chapters\n            });\n        }\n    };\n});\n\n            System.import(\"info\");\n            "},"output":{"image":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"link":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"title":"","description":"","genres":[""],"field1":"","field2":"","field3":"","field4":"","chapters":[{"chapName":"","openInWebView":false,"link":{"url":"https://google.com/","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]},"fileType":"info","fileSection":"Module","fileID":1303432505,"fileName":"info.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport { cleanUrl, cleanText, cleanImage } from './shared';\n\nlet res = await core.dynamicFetch({loadInSite: true, removeScripts: false});\n\n// Extract basic info\nconst title = cleanText(res.querySelector('h1')?.textContent || '');\nconst image = core.request(cleanImage(res.querySelector('img')?.getAttribute('src') || ''));\n\nconst nextDataScript = JSON.parse(res.querySelector('script[id=__NEXT_DATA__]')?.textContent || '{}').props?.pageProps || {};\n\nconst seriesInfo = nextDataScript?.series;\nconst synopsis = seriesInfo.description || '';\nconst state = seriesInfo?.status || '';\nconst type = seriesInfo?.type || '';\n\n// Extract genres\nconst genres = seriesInfo?.tags;\n\n// Extract chapters from Next.js data\nlet chapters: any[] = [];\n\nif (nextDataScript) {\n    try {\n        const chaptersData = nextDataScript.chapters || [];\n\n        chapters = chaptersData.map((entry: any) => {\n            const chapterNum = entry.chapter?.replace('.00', '') || '';\n            const link = cleanUrl(`/series/${entry.series_id}/${entry.token}`);\n            const name = `Chapter ${chapterNum}`;\n\n            return core.chapterRequest(link, {\n                name: name,\n                openInWebView: false\n            });\n        }).reverse();\n    } catch (error) {\n        console.error('Error parsing chapter data:', error);\n    }\n}\n\n// Build info page\ncore.info({\n    title: title,\n    image: image,\n    description: synopsis,\n    genres: genres,\n    field1: type,\n    field2: state,\n    field4: `Chapters: ${chapters.length}`,\n    chapters: chapters\n});\n","type":"typescript","compiled":true,"status":true,"shared":false,"line":53}},"fileIndexPath":[5,0]}],"chapters":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            store.set(\"ketsu_dynamic_raw\", currentURL); // THIS\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: request(store.get(\"ketsu_dynamic_raw\") || metadata().request.url),\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"chapters\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core, res, imageElements, images;\n    var __moduleName = context_2 && context_2.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: async function () {\n            res = await core.dynamicFetch({ loadInSite: true, removeScripts: false });\n            // Extract images from the chapter page\n            imageElements = Array.from(res.querySelectorAll('img[decoding=async][my=none]'));\n            images = imageElements\n                .map((img) => img.getAttribute('src') || '')\n                .filter((src) => src.length > 0)\n                .map((src) => core.request(src));\n            core.chapters(images);\n        }\n    };\n});\n\n            System.import(\"chapters\");\n            "},"output":{"videos":{"needsResolver":[{"resolverIdentifier":"","link":{"url":"","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}],"rawVideo":[{"video":[{"videoQuality":"","videoLink":{"url":"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}]},"images":[{"url":"empty","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}],"text":{"text":""}},"fileType":"chapters","fileSection":"Module","fileID":2241182013,"fileName":"chapters.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\n\nlet res = await core.dynamicFetch({loadInSite: true, removeScripts: false});\n\n// Extract images from the chapter page\nconst imageElements = Array.from(res.querySelectorAll('img[decoding=async][my=none]'));\n\nconst images = imageElements\n    .map((img: any) => img.getAttribute('src') || '')\n    .filter((src: string) => src.length > 0)\n    .map((src: string) => core.request(src));\n\ncore.chapters(images);\n","type":"typescript","compiled":true,"status":true,"shared":false,"line":14}},"fileIndexPath":[6,0]}],"moduleResolvers":[{"resolverInfo":{"resolverName":"","nameMatches":[""],"developer":"","moduleID":"","resolverVersion":1,"baseURL":""},"resolver":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":false,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            store.set(\"ketsu_dynamic_raw\", currentURL); // THIS\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: request(store.get(\"ketsu_dynamic_raw\") || metadata().request.url),\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"moduleResolvers\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n            core.log(\"hello\");\n            core.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"));\n        }\n    };\n});\n\n            System.import(\"moduleResolvers\");\n            "},"output":{"moduleID":"","video":[{"videoQuality":"720","videoLink":{"url":"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}}],"fileType":"moduleResolvers","fileSection":"Resolvers","fileID":4087012470,"fileName":"moduleResolvers.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["resolver",0,"javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\n\ncore.log(\"hello\")\n\n\ncore.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"))","type":"typescript","compiled":true,"status":true,"shared":false,"line":6},"params":{"name":"Settings Editor","route":["resolverInfo"],"status":false}},"fileIndexPath":[7,0]},{"resolverInfo":{"resolverName":"","nameMatches":[""],"developer":"","moduleID":"","resolverVersion":1,"baseURL":""},"resolver":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":false,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            store.set(\"ketsu_dynamic_raw\", currentURL); // THIS\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: request(store.get(\"ketsu_dynamic_raw\") || metadata().request.url),\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"2116698741\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n            core.log(\"wtf\");\n            core.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"));\n        }\n    };\n});\n\n            System.import(\"2116698741\");\n            "},"output":{"moduleID":"","video":[{"videoQuality":"720","videoLink":{"url":"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}}],"fileIndexPath":[7,1],"fileType":"moduleResolvers","fileSection":"Resolvers","fileID":2116698741,"fileName":"2116698741.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["resolver",0,"javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\n\n\ncore.log(\"wtf\")\ncore.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"))","compiled":true,"status":true,"shared":false,"line":5},"params":{"name":"Settings Editor","route":["resolverInfo"],"status":false}}}],"responseCodeFunctions":[{"code":0,"msgTitle":"","msgBody":"","type":"normal","functions":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":""}}],"fileType":"responseCodeFunctions","fileSection":"Helpers","fileID":2061855769,"fileName":"responseCodeFunctions.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":true}}}],"helperFunctions":[{"functionName":"example","msgTitle":"","msgBody":"","type":"normal","functions":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n        try {\n\n            /* JAVASCRIPT STARTS */ \n /* JAVASCRIPT ENDS */\n\n        } catch (e) {\n            console.error(e.message);\n\n            if (typeof KETSU_ASYNC !== 'undefined') {\n                window.webkit.messageHandlers.EXECUTE_KETSU_ASYNC.postMessage('');\n            }\n\n        }\n        \n        "}}],"fileType":"helperFunctions","fileSection":"Helpers","fileID":3330151581,"fileName":"helperFunctions.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":true}}}],"moduleCreator":{"currentFile":2253367988,"name":""},"core":{"compiledJS":"","fileType":"core","fileSection":"Shared","fileID":2698950564,"fileName":"core.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["compiledJS"],"name":"Code Editor","data":"// MARK:GLOBAL\n(window as any).KETSU_ASYNC = true\nconst emptyKeyVal: KeyValue[] = [{ key: \"\", value: \"\" }]\n\n/**\n * Ketsu Framework - A TypeScript/JavaScript framework to simplify KETSU module making.\n * \n * This framework provides utilities for:\n * - Making HTTP requests with caching and site loading capabilities\n * - Creating UI layouts and views for content display\n * - Handling different page types (main, search, info, chapters)\n * - Managing video content with resolvers and subtitles\n * - Storing and retrieving data\n * - Logging and debugging\n */\n\n\n// MARK: TYPE HELPERS\n\ntype Prettify<T> = { [K in keyof T]: T[K] } & {}\n\n// MARK: REQUEST\n\ntype FetchMethods = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\" | \"HEAD\" | \"OPTIONS\" | \"CONNECT\" | \"TRACE\";\n\n/**\n * Standard fetch options for HTTP requests\n */\ninterface FetchOptions {\n    /** HTTP method to use (default: \"GET\") */\n    method?: FetchMethods;\n    /** Request headers as key-value object */\n    headers?: Record<string, string>;\n    /** Request body content */\n    body?: string;\n}\n\n/**\n * Extended fetch options with Ketsu-specific features\n */\ninterface KetsuFetchOptions extends FetchOptions {\n    /** Whether to remove JavaScript from fetched HTML (default: false) */\n    removeScripts?: boolean;\n    /** Whether to load the content within the site's webview (default: false) */\n    loadInSite?: boolean;\n}\n\n/**\n * Function that runs within a fetched site's context\n */\ntype RunWithinSite<T extends any = any> = [run?: (window: Window) => T]\n\n/**\n * Extracts the return type from an async function\n */\ntype ResolveAsync<T> = T extends Promise<infer R> ? R : T\n\n/**\n * Extracts the return type from a function\n */\ntype ExtractReturnType<T> = T extends ((...args: any[]) => infer U) ? ResolveAsync<U> : never\n\n/**\n * Makes an HTTP request to a website, you can also run javascript directly on the website.\n * @param url - The URL to fetch\n * @param options - Fetch configuration options\n * @param run - Optional function to execute within the fetched site's context\n * @returns Promise resolving to either HTML element or the result of the run function\n * \n * @example\n * // Simple fetch\n * const html = await fetch(\"https://example.com\");\n * \n * @example\n * // Fetch and execute code in site context\n * const result = await fetch(\"https://example.com\", {}, (window) => {\n *   return window.document.title;\n * });\n */\nexport async function fetch<T extends RunWithinSite>(\n    url: string,\n    options: Prettify<KetsuFetchOptions> = {},\n    ...run: T\n): Promise<T extends [] ? HTMLElement : ExtractReturnType<T[0]>> {\n    let meta = metadata()\n    let metaUrl = meta.request.url\n    if (url === metaUrl) {\n        let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML\n        store.set(url, res)\n        return run.length > 0 ? res : window.document.documentElement\n    }\n    let cached = store.get(url)\n    if (cached === undefined) {\n        meta.request = request(url, options)\n        meta.javascriptConfig.loadInWebView = options.loadInSite ?? false\n        meta.javascriptConfig.removeJavascript = options.removeScripts ?? false\n        return finish() as any\n    }\n    return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n        (new DOMParser()).parseFromString(cached, \"text/html\").documentElement as any :\n        cached as any\n}\n\n/**\n * Extended fetch options for dynamic requests\n */\ninterface DynamicFetchOptions extends KetsuFetchOptions {\n    /** Test URL to use instead of dynamic resolution */\n    testURL?: string;\n}\n\n/**\n * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n * @param options - Dynamic fetch configuration options\n * @param run - Optional function to execute within the fetched site's context\n * @returns Promise resolving to either HTML element or the result of the run function\n * \n * @example\n * // Dynamic fetch with test URL\n * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n */\nexport async function dynamicFetch<T extends RunWithinSite>(\n    _options: Prettify<DynamicFetchOptions> = {},\n    ...run: T\n): Promise<T extends [] ? HTMLElement : ExtractReturnType<T[0]>> {\n    let meta = metadata();\n    let currentURL = meta.request.url;\n    let url: string | undefined = store.get(\"ketsu_dynamic\");\n    let options = _options;\n\n    if (options.testURL) {\n        url = options.testURL;\n    }\n\n    if (!url) {\n        if (!currentURL.includes(\"ketsu_dynamic=\")) {\n            throw new Error(\"No dynamic URL available and no testURL provided.\");\n        }\n        store.set(\"ketsu_dynamic_raw\",currentURL) // THIS\n        const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n        const originalRequest: Request = JSON.parse(decodeURIComponent(encoded));\n\n        url = originalRequest.url;\n\n        // Merge headers/body/method only if not already defined\n        options.method ??= originalRequest.method;\n        options.body ??= originalRequest.httpBody;\n        const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n        options.headers = {\n            ...originalHeaders,\n            ...options.headers\n        };\n        // Save resolved URL to prevent repeating decoding later\n        store.set(\"ketsu_dynamic\", url);\n    }\n\n    return fetch(url, options, ...run);\n}\n\n\nexport function toast(text: string): void {\n    action(\"KETSU_MSG\", text)\n}\n\n// MARK: REQUEST\n\n/**\n * Creates a request object for KETSU\n * @param url - The target URL\n * @param options - Request configuration options\n * @returns Request object formatted for the Ketsu framework\n * \n * @example\n * const req = request(\"https://api.example.com\", {\n *   method: \"POST\",\n *   headers: { \"Content-Type\": \"application/json\" },\n *   body: JSON.stringify({ data: \"example\" })\n * });\n */\nexport function request(url: string, options: Prettify<FetchOptions> = {}): Request {\n    return {\n        url: url,\n        method: options.method || \"GET\",\n        headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n        httpBody: options.body\n    }\n}\n\nfunction dynamicRequest(request: Request): Request {\n    return {\n        url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n        method: \"GET\",\n        headers: emptyKeyVal,\n        httpBody: undefined\n    }\n}\n\n// MARK: LAYOUT\n\n/**\n * Layout distribution options for organizing content views\n */\ntype Distributions =\n    | 'ultraWideFull' | 'ultraWide'\n    | 'wideFull' | 'wide' | 'wideStrechedFull' | 'WideStrechedFullDouble'\n    | 'wideStreched' | 'wideStrechedDouble' | 'wideStrechedFullList' | 'wideStrechedList'\n    | 'doublets' | 'doubletsDouble' | 'doubletsFull' | 'doubletsFullDouble'\n    | 'doubletsConstant' | 'doubletsDoubleConstant' | 'doubletsFullConstant' | 'doubletsFullDoubleConstant'\n    | 'longDoublets' | 'longDoubletsDouble' | 'longDoubletsFull' | 'longDoubletsFullDouble'\n    | 'longDoubletsConstant' | 'longDoubletsDoubleConstant' | 'longDoubletsFullConstant' | 'longDoubletsFullDoubleConstant'\n    | 'triplets' | 'tripletsDouble' | 'tripletsFull' | 'tripletsFullDouble'\n    | 'tripletsConstant' | 'tripletsDoubleConstant' | 'tripletsFullConstant' | 'tripletsFullDoubleConstant'\n    | 'longTriplets' | 'longTripletsDouble' | 'longTripletsFull' | 'longTripletsFullDouble'\n    | 'longTripletsConstant' | 'longTripletsDoubleConstant' | 'longTripletsFullConstant' | 'longTripletsFullDoubleConstant';\n\n/**\n * Visual design styles for content cells\n */\ntype Designs =\n    | 'Special1' | 'Special2' | 'Special3' | 'CELLHelperText'\n    | 'small1' | 'small2'\n    | 'normal1' | 'normal2' | 'normal3' | 'normal4' | 'normal5' | 'normal7'\n    | 'wide1' | 'wide2' | 'wide3' | 'wide4' | 'wide5' | 'wide6' | 'wide7' | 'wide8' | 'wide9' | 'wide10' | 'wide11';\n\n\nconst defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\")\nconst defaultRequest = request(\"https://www.google.com/\")\n\n/**\n * Container for organizing multiple content views\n */\ninterface ViewsHolder {\n    /** Section title */\n    title: string;\n    /** Visual design style for the views */\n    design: Designs;\n    /** Layout distribution pattern */\n    distribution: Distributions;\n    /** Orientation of the layout */\n    orientation: \"vertical\" | \"horizontal\";\n    /** Array of content views */\n    views: View[];\n}\n\ntype _ViewsHolder = Prettify<Partial<ViewsHolder>>\n\nexport function viewsHolder(h: _ViewsHolder): ViewsHolder {\n    return {\n        cellDesing: h.design || \"wide5\",\n        defaultLayout: h.distribution || \"wideStrechedFullList\",\n        orientation: h.orientation || \"vertical\",\n        section: {\n            sectionName: h.title || \"\",\n            separator: true\n        },\n        paging: \"leading\",\n        data: h.views || [],\n        layout: undefined,\n    } as any\n}\n\n\n/**\n * Individual content view item\n */\ninterface View {\n    /** Navigation link for the view */\n    link: Request;\n    /** Image/thumbnail for the view */\n    image: Request;\n    /** Primary title text */\n    title: string;\n    /** Description text */\n    description: string;\n    /** Additional field 1 */\n    field1: string;\n    /** Additional field 2 */\n    field2: string;\n    /** Additional field 3 */\n    field3: string;\n    /** Additional field 4 */\n    field4: string;\n    /** Whether this view represents a chapter */\n    isChapter: boolean;\n    /** Whether to open in webview */\n    openInWebView: boolean;\n}\n\n\n/**\n * Creates a views holder container with default values\n * @param h - Partial views holder configuration\n * @returns Complete ViewsHolder object with defaults applied\n * \n * @example\n * const holder = viewsHolder({\n *   title: \"Popular Movies\",\n *   design: \"wide5\",\n *   distribution: \"doublets\",\n *   views: [view1, view2, view3]\n * });\n */\ntype _View = Prettify<Partial<Omit<View, \"openInWebView\" | \"isChapter\">>>\n\n/**\n * Creates a content view with default values\n * @param v - Partial view configuration\n * @returns Complete View object with defaults applied\n * \n * @example\n * const movieView = view({\n *   title: \"The Matrix\",\n *   description: \"A computer hacker learns about reality\",\n *   image: request(\"https://example.com/matrix.jpg\"),\n *   link: request(\"https://example.com/matrix\")\n * });\n */\nexport function view(v: _View): View {\n    return {\n        link: dynamicRequest(v.link || defaultRequest),\n        image: v.image || defaultImage,\n        title: v.title || \"\",\n        description: v.description || \"\",\n        field1: v.field1 || \"\",\n        field2: v.field2 || \"\",\n        field3: v.field3 || \"\",\n        field4: v.field4 || \"\",\n        isChapter: false,\n        openInWebView: false\n    }\n}\n\n\n// MARK: MAINPAGE\n\n/**\n * Sets up the main page layout with the provided view holders\n * @param layout - Array of ViewsHolder objects to display on the main page\n * \n * @example\n * main([\n *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n *   viewsHolder({ title: \"Popular\", views: popularViews })\n * ]);\n */\nexport function main(layout: ViewsHolder[]): void {\n    metadata().output = layout\n    finish()\n}\n\n// MARK: SEARCHPAGE\n\n/**\n * Sets up the search results page layout\n * @param layout - Array of ViewsHolder objects to display search results\n * \n * @example\n * search([\n *   viewsHolder({ title: \"Search Results\", views: searchResults })\n * ]);\n */\nexport function search(layout: ViewsHolder[]): void {\n    metadata().output = layout\n    finish()\n}\n\n/**\n * Search metadata information\n */\ninterface SearchMetadata {\n    /** Current search query */\n    searched: string;\n    /** Current page number (0-based) */\n    page: number;\n}\n\n/**\n * Retrieves current search metadata (query and page), must be used at the start of the search script.\n * @param test - Optional test metadata to override URL parsing\n * @returns Search metadata object\n * \n * @example\n * const { searched, page } = searchMetadata();\n * console.log(`Searching for: ${searched}, Page: ${page}`);\n */\nexport function searchMetadata(test?: Prettify<Partial<SearchMetadata>>): Prettify<SearchMetadata>{\n    let meta = metadata()\n    let searchMeta = store.get<SearchMetadata>(\"ketsu_search\")\n\n    if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n        let url = new URL(meta.request.url).searchParams\n        let searched = url.get(\"ketsu_search\") || \"\"\n        let page = parseInt(url.get(\"page\") || \"0\", 10)\n        searchMeta = {\n            searched: test?.searched ? test.searched : searched,\n            page: test?.page ? test.page : page\n        }\n        store.set(\"ketsu_search\", searchMeta)\n    }\n\n    return searchMeta || { searched: \"\", page: 0 }\n}\n\n// MARK: INFOPAGE\n/**\n * Chapter request configuration\n */\ninterface ChapterRequest {\n  /** Optional chapter name */\n  chapName?: string;\n  /** Navigation link for the chapter */\n  link: Request;\n  /** Whether to open in webview */\n  openInWebView: boolean;\n}\n\n/**\n * Options for creating chapter requests\n */\ninterface ChapterRequestOptions extends FetchOptions {\n  /** Chapter name */\n  name?: string;\n  /** Whether to open in webview */\n  openInWebView?: boolean;\n}\n\n/**\n * Creates a chapter request object\n * @param url - Chapter URL\n * @param options - Chapter configuration options\n * @returns ChapterRequest object\n * \n * @example\n * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n *   name: \"Chapter 1: The Beginning\",\n *   openInWebView: false\n * });\n */\nexport function chapterRequest(url: string, options: Prettify<ChapterRequestOptions> = {}): ChapterRequest {\n    return {\n        chapName: options.name,\n        link: dynamicRequest(request(url, options)),\n        openInWebView: options.openInWebView ?? false\n    };\n}\n\n\n/**\n * Information page structure for detailed content view\n */\ninterface InfoPage {\n  /** Main image for the content */\n  image: Request;\n  /** Navigation link */\n  link: Request;\n  /** Content title */\n  title: string;\n  /** Content description */\n  description: string;\n  /** Array of genre tags */\n  genres: string[];\n  /** Additional field 1 */\n  field1: string;\n  /** Additional field 2 */\n  field2: string;\n  /** Additional field 3 */\n  field3: string;\n  /** Additional field 4 */\n  field4: string;\n  /** Array of available chapters */\n  chapters: ChapterRequest[];\n}\n\n\ntype _InfoPage = Prettify<Partial<InfoPage>>\n\n/**\n * Sets up an information/detail page\n * @param data - Partial info page configuration\n * \n * @example\n * info({\n *   title: \" Some title\",\n *   description: \"A high school chemistry teacher turned meth cook\",\n *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n *   chapters: [chapter1, chapter2, chapter3]\n * });\n */\nexport function info(data: _InfoPage): void {\n    let l: InfoPage = {\n        image: data.image || defaultImage,\n        link: request(store.get<string>(\"ketsu_dynamic_raw\") || metadata().request.url),        \n        title: data.title || \"\",\n        description: data.description || \"\",\n        genres: data.genres || [],\n        field1: data.field1 || \"\",\n        field2: data.field2 || \"\",\n        field3: data.field3 || \"\",\n        field4: data.field4 || \"\",\n        chapters: data.chapters || []\n    }\n    metadata().output = l\n    finish()\n}\n\n// MARK: CHAPTERS \n\n/**\n * Chapter content with video support\n */\ninterface ChapterVideos {\n  videos?: {\n    /** Videos that need URL resolution */\n    needsResolver?: ResolverRequest[];\n    /** Direct video URLs */\n    rawVideo?: VideoRequest[];\n  };\n}\n\n/**\n * Chapter content with image support\n */\ninterface ChapterImages {\n  /** Array of image requests */\n  images?: Request[];\n}\n\n\n/**\n * Chapter content with text support\n */\ninterface ChapterText {\n  text?: {\n    /** Text content */\n    text: string;\n  };\n}\n\n\n/**\n * Combined chapter content interface\n */\ninterface Chapter extends ChapterVideos, ChapterImages, ChapterText {\n\n}\n\n/**\n * Sets up chapter content (videos, images, or text)\n * @param data - Chapter content data (images, videos, or text string)\n * \n * @example\n * // For image-based content (manga)\n * chapters([\n *   request(\"https://example.com/page1.jpg\"),\n *   request(\"https://example.com/page2.jpg\")\n * ]);\n * \n * @example\n * // For video content\n * chapters([\n *   videoRequest(\"https://example.com/video.mp4\"),\n *   resolverRequest(\"https://example.com/embed\")\n * ]);\n * \n * @example\n * // For text content\n * chapters(\"This is the chapter text content...\");\n */\nexport function chapters(data: Request[] | (VideoRequest | ResolverRequest)[] | string): void {\n    let output: Chapter = {\n        videos: undefined,\n        text: undefined,\n        images: undefined\n    };\n\n    if (!Array.isArray(data)) {\n        if (typeof data !== \"string\") {\n            throw new Error(\"Chapters type is wrong\")\n        }\n        output.text = { text: data };\n    }\n\n    if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n        output.images = data as Request[]\n    } else if (Array.isArray(data)) {\n\n        output.videos = {\n            needsResolver: [],\n            rawVideo: []\n        }\n\n        data.forEach((v) => \"video\" in v ? output!.videos!.rawVideo!.push(v) : output!.videos!.needsResolver!.push(v as any))\n\n    }\n\n    metadata().output = output;\n    finish();\n}\n\n\n// MARK: RESOLVE\n\n/**\n * Returns the video resolved from the embeded website.\n * @param video - VideoRequest object to resolve\n * \n * @example\n * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n * resolver(resolvedVideo);\n */\nexport function resolver(video: VideoRequest): void {\n    metadata().output = video;\n    finish();\n}\n\n/**\n * Resolver request options\n */\ninterface ResolverRequestOptions extends FetchOptions {\n  /** Unique resolver identifier, example https://streamwebsite.com/..  \n   * The id would be: STREAMWEBSITE this is automatically extracted if left unedfined.*/\n  resolverID?: string;\n}\n\n/**\n * Video resolver request for extracting video URLs\n */\ninterface ResolverRequest {\n  /** Unique resolver identifier */\n  resolverIdentifier: string;\n  /** Request to the resolver endpoint */\n  link: Request;\n}\n\n\n/**\n * Creates a resolver request for extracting video URLs from embed pages\n * @param url - URL to the video resolver/embed page\n * @param options - Resolver configuration options\n * @returns ResolverRequest object\n * \n * @example\n * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n *   resolverID: \"STREAMWEBSITE\" // \n * });\n */\nexport function resolverRequest(url: string, options?: Prettify<ResolverRequestOptions>): ResolverRequest {\n    return {\n        link: dynamicRequest(request(url, options)),\n        resolverIdentifier: options?.resolverID || \"\"\n    }\n}\n\n/**\n * Subtitle request options\n */\ninterface SubsRequestOptions extends FetchOptions {\n  /** Subtitle language */\n  language?: string;\n}\n\n/**\n * Subtitle request configuration\n */\ninterface SubsRequest {\n  /** Request to subtitle file */\n  link: Request;\n  /** Subtitle language */\n  language: string;\n}\n\n/**\n * Creates a subtitle request\n * @param url - URL to subtitle file\n * @param options - Subtitle configuration options\n * @returns SubsRequest object\n * \n * @example\n * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n *   language: \"English\"\n * });\n */\nexport function subsRequest(url: string, options?: Prettify<SubsRequestOptions>): SubsRequest {\n    return {\n        link: request(url, options),\n        language: options?.language || \"unknown\"\n    }\n}\n\n/**\n * Video request options\n */\ninterface VideoRequestOptions extends FetchOptions {\n  /** Video quality identifier */\n  quality?: string;\n  /** Array of subtitle requests */\n  subs?: SubsRequest[];\n}\n\n/**\n * Internal video request structure\n */\ninterface _VideoRequest {\n  /** Request to video file */\n  videoLink: Request;\n  /** Video quality identifier */\n  videoQuality: string;\n}\n/**\n * Complete video request with subtitles\n */\ninterface VideoRequest extends VideoRequestOptions {\n  /** Array of video sources */\n  video: _VideoRequest[];\n  /** Array of subtitle requests */\n  subs?: SubsRequest[];\n}\n\n\n/**\n * Creates a video request with quality and subtitle options\n * @param url - Direct video URL\n * @param options - Video configuration options\n * @returns VideoRequest object\n * \n * @example\n * const video = videoRequest(\"https://example.com/video.mp4\", {\n *   quality: \"1080p\",\n *   subs: [\n *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n *   ]\n * });\n */\nexport function videoRequest(url: string, options?: VideoRequestOptions): VideoRequest {\n    return {\n        video: [{\n            videoLink: request(url, options),\n            videoQuality: options?.quality || \"auto\"\n        }],\n        subs: options?.subs\n    }\n}\n\n\n// MARK: METADATA\n\ninterface KeyValue {\n    key: string;\n    value: string;\n}\n\ninterface Request {\n    url: string;\n    method: FetchMethods;\n    headers: KeyValue[];\n    httpBody?: string\n}\n\ninterface JavascriptConfig {\n    loadInWebView: boolean;\n    javaScript: string;\n    removeJavascript: boolean;\n}\n\ninterface Command {\n    commandName: string;\n    params: KeyValue[];\n}\n\ninterface Extra {\n    commands: Command[];\n    extraInfo: KeyValue[];\n}\n\ninterface Global {\n    cookies: KeyValue[];\n    headers: KeyValue[];\n    variables: KeyValue[];\n}\n\ninterface ResponseInfo {\n    headers: KeyValue[];\n    responseUrl: string;\n    httpBody: string;\n}\n\ninterface KetsuMetadata {\n    request: Request;\n    separator: string;\n    javascriptConfig: JavascriptConfig;\n    extra: Extra;\n    global: Global;\n    responseInfo: ResponseInfo;\n    output: any\n}\n\nvar _metadata: KetsuMetadata | undefined = undefined\n\nfunction metadata(): KetsuMetadata {\n\n    if (!_metadata) {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata = JSON.parse(savedData?.textContent || \"\")\n    }\n\n    return _metadata as KetsuMetadata\n}\n\n// MARK: Finish\n\nfunction finish(): void {\n    const savedData = document.getElementById('ketsu-final-data');\n    _metadata ? (savedData!.textContent = JSON.stringify(_metadata)) : (undefined)\n    _logs.forEach((l) => action(\"KETSU_LOG\", l))\n    action(\"EXECUTE_KETSU_ASYNC\")\n    throw new Error()\n}\n\n// MARK: STORE\n\n\n\n/**\n * Key-value storage interface\n */\ninterface Store<T extends string = string> {\n  /**\n   * Stores a value with the given key\n   * @param key - Storage key\n   * @param val - Value to store\n   * @param persist - Whether to persist across scripts\n   */\n  set: (key: T, val: any, persist?: boolean) => void;\n  \n  /**\n   * Retrieves a value by key\n   * @param key - Storage key\n   * @returns Stored value or undefined\n   */\n  get: <R>(key: T) => R | undefined;\n  \n  /**\n   * Checks if a key exists in storage\n   * @param key - Storage key\n   * @returns True if key exists\n   */\n  has: (key: T) => boolean;\n}\n\n\nconst _store: Record<string, string> = {\n    ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n        acc[val.key] = val.value\n        return acc\n    }, {} as Record<string, string>)\n}\n\n/**\n * Global storage instance for persisting data\n * \n * @example\n * // Store data\n * store.set(\"user_preferences\", { theme: \"dark\" });\n * \n * // Retrieve data\n * const prefs = store.get(\"user_preferences\");\n * \n * // Check if key exists\n * if (store.has(\"user_preferences\")) {\n *   // Key exists\n * }\n */\nexport const store: Store = {\n    set: (key, value, persist = false) => {\n        let val = encodeURIComponent(JSON.stringify({ value: value }))\n        persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val)\n    },\n    get: (key) => {\n        let val: any = undefined\n        try {\n            val = JSON.parse(decodeURIComponent(_store[key])).value\n        } catch {\n            log(`key: ${key} not found in the store.`)\n        }\n        return val\n    },\n    has: (key) => (key in _store)\n}\n\nfunction setExtraInfo(key: string, value: string): void {\n    let meta = metadata()\n    let kv = meta.extra.extraInfo.find((k) => k.key === key)\n    if (!kv) {\n        kv = {\n            key: \"\",\n            value: \"\"\n        }\n        meta.extra.extraInfo.push(kv)\n    }\n    kv.key = key\n    kv.value = value\n}\n\n\n// MARK: COMMAND\ntype Commands = \"persistant\" | \"variable\" | \"cookie\" | \"header\" | \"helperFunction\" | (string & {})\nfunction setCommand(name: Commands, key: string, value: string): void {\n    let meta = metadata()\n    let command = meta.extra.commands.find((c) => c.commandName == name)\n    if (!command) {\n        command = {\n            commandName: name,\n            params: []\n        }\n        meta.extra.commands.push(command)\n    }\n    command.params.push({ key, value })\n}\n\n\n// MARK: ACTIONS\ntype Actions = \"EXECUTE_KETSU_ASYNC\" | \"KETSU_LOG\" | \"KETSU_MSG\"\nfunction action(name: Actions, val: string = \"\"): void {\n    if (\"webkit\" in window) {\n        (window as any).webkit.messageHandlers[name].postMessage(val);\n    } else if (name === \"KETSU_LOG\") {\n        console.log(val)\n    }\n}\n\n\n// MARK: LOGS\nlet _logs: string[] = []\n\n/**\n * Logs messages for debugging purposes\n * @param args - Values to log\n * \n * @example\n * log(\"Debug message\", { data: \"example\" });\n * log(\"User action:\", userAction, \"Result:\", result);\n */\nexport function log(...args: any[]): void {\n    const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n    _logs.push(stringifiedArgs)\n}\n\nfunction stringify(value: any): string {\n    // Primitives\n    if (value === null) return 'null';\n    if (value === undefined) return 'undefined';\n    if (typeof value === 'string') return value;\n    if (typeof value === 'number' || typeof value === 'boolean') return String(value);\n\n    // Functions\n    if (typeof value === 'function') {\n        return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    // Errors\n    if (value instanceof Error) {\n        return `${value.name}: ${value.message}`;\n    }\n\n    // Everything else - just stringify with pretty print\n    try {\n        return JSON.stringify(value, (key, val) => {\n            if (typeof val === 'function') {\n                return `[Function: ${val.name || 'anonymous'}]`;\n            }\n            if (val instanceof Error) {\n                return `${val.name}: ${val.message}`;\n            }\n            return val;\n        }, 2);\n    } catch (e) {\n        return `[${value.constructor?.name || 'Object'}]`;\n    }\n}\n\n","type":"typescript","compiled":false,"status":true,"shared":true,"line":927}},"fileIndexPath":[0,0]},"shared":{"compiledJS":"","fileType":"shared","fileSection":"Shared","fileID":925957622,"fileName":"shared.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":true},"code":{"route":["compiledJS"],"name":"Code Editor","data":"export function cleanUrl(url: string): string {\r\n  return 'https://flamecomics.xyz' + url.trim();\r\n}\r\n\r\nexport function cleanText(str: string): string {\r\n  return str.replace(/[\\n\\t]/g, '').trim();\r\n}\r\n\r\nexport function cleanImage(imageUrl: string): string {\r\n  // If image already has domain, return as-is\r\n  if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {\r\n    return imageUrl;\r\n  }\r\n  // Otherwise, prepend FlameComics domain\r\n  return 'https://flamecomics.xyz' + imageUrl;\r\n}\r\n","type":"typescript","compiled":false,"status":true,"shared":true,"line":17}},"fileIndexPath":[1,0]}}